/*
This code contains portions of source code from 
https://github.com/ebruneton/precomputed_atmospheric_scattering/blob/master/atmosphere/functions.glsl
Copyright (c) 2017 Eric Bruneton
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. Neither the name of the copyright holders nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.
*/

#version 460

#include "Atmosphere.glsl"

layout(binding = 0) uniform sampler2D transmittance_texture;
layout(binding = 1) uniform sampler2D multiscattering_texture;

layout(binding = 0, SCATTERING_FORMAT) uniform image3D scattering_image;
layout(binding = 1, SCATTERING_FORMAT) uniform image3D single_mie_scattering_image;

void ComputeSingleScattering(
        float r, float mu, float mu_s, float nu,
        bool ray_r_mu_intersects_ground,
        out vec3 rayleigh, out vec3 mie) {

    // Number of intervals for the numerical integration.
    const int SAMPLE_COUNT = 50;
    // The integration step, i.e. the length of each integration interval.
    float dx = DistanceToNearestAtmosphereBoundary(r, mu,
            ray_r_mu_intersects_ground) / float(SAMPLE_COUNT);
    // Integration loop.
    vec3 rayleigh_sum = vec3(0.0);
    vec3 mie_sum = vec3(0.0);
    vec3 transmittance = vec3(1);
    for (int i = 0; i < SAMPLE_COUNT; ++i) {
        float d_i = (float(i) + 0.5) * dx;
        // The Rayleigh and Mie single scattering at the current sample point.
        vec3 rayleigh_i;
        vec3 mie_i;
    
        float d = d_i;
        float r_d = ClampRadius(sqrt(d * d + 2.0 * r * mu * d + r * r));
        float mu_s_d = ClampCosine((r * mu_s + d * nu) / r_d);
        vec3 transmittance_to_sun = GetSunVisibility(transmittance_texture, r_d, mu_s_d);
        
        float altitude_i = r_d - bottom_radius;
        vec3 rayleigh_scattering_i;
        vec3 mie_scattering_i;
        GetScatteringCoefficient(altitude_i, rayleigh_scattering_i, mie_scattering_i);
        
        vec3 extinction_i = GetExtinctionCoefficient(altitude_i);
        vec3 transmittance_i = exp(-extinction_i * dx);

#if USE_MULTISCATTERING_LUT
        vec3 multiscattering_contribution = GetMultiscatteringContribution(multiscattering_texture, r_d, mu_s_d);
        multiscattering_contribution /= RayleighPhaseFunction(nu);
        rayleigh_i = rayleigh_scattering_i * (transmittance_to_sun + multiscattering_contribution)
            + mie_scattering_i * multiscattering_contribution;
#else
        rayleigh_i = rayleigh_scattering_i * transmittance_to_sun;
#endif
        mie_i = mie_scattering_i * transmittance_to_sun;

        // See slide 28 at https://www.frostbite.com/2015/08/physically-based-unified-volumetric-rendering-in-frostbite/
        rayleigh_sum += transmittance * (rayleigh_i - rayleigh_i * transmittance_i) / extinction_i;
        mie_sum += transmittance * (mie_i - mie_i * transmittance_i) / extinction_i;
        transmittance *= transmittance_i;
    }
    rayleigh = rayleigh_sum * solar_illuminance;
    mie = mie_sum * solar_illuminance;
}

void ComputeSingleScatteringTexture(vec3 frag_coord, out vec3 rayleigh, out vec3 mie) {
    float r;
    float mu;
    float mu_s;
    float nu;
    bool ray_r_mu_intersects_ground;
    GetRMuMuSNuFromScatteringTextureFragCoord(frag_coord,
        r, mu, mu_s, nu, ray_r_mu_intersects_ground);
    ComputeSingleScattering(r, mu, mu_s, nu, ray_r_mu_intersects_ground, rayleigh, mie);
}

void main() {
	vec3 frag_coord = vec3(gl_GlobalInvocationID) + 0.5;
    
    vec3 delta_rayleigh, delta_mie;
    ComputeSingleScatteringTexture(
        frag_coord, delta_rayleigh, delta_mie);
    vec4 scattering = vec4(delta_rayleigh.rgb, delta_mie.r);
	imageStore(scattering_image, ivec3(gl_GlobalInvocationID), scattering);
#if !(COMBINED_SCATTERING_TEXTURES && USE_MULTISCATTERING_LUT)
	imageStore(single_mie_scattering_image, ivec3(gl_GlobalInvocationID), vec4(delta_mie, 1.0));
#endif
}
