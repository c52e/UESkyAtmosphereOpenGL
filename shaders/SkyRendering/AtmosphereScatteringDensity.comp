/*
This code contains portions of source code from 
https://github.com/ebruneton/precomputed_atmospheric_scattering/blob/master/atmosphere/functions.glsl
Copyright (c) 2017 Eric Bruneton
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. Neither the name of the copyright holders nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.
*/

#version 460
#include "Atmosphere.glsl"

layout(binding = 0) uniform sampler2D transmittance_texture;
layout(binding = 1) uniform sampler3D single_rayleigh_scattering_texture;
layout(binding = 2) uniform sampler3D single_mie_scattering_texture;
layout(binding = 3) uniform sampler3D multiple_scattering_texture;
layout(binding = 4) uniform sampler2D irradiance_texture;

layout(binding = 0, SCATTERING_FORMAT) uniform image3D scattering_density_image;

layout(location = 0) uniform int scattering_order;

vec2 GetIrradianceTextureUvFromRMuS(float r, float mu_s) {
    float x_r = (r - bottom_radius) / (top_radius - bottom_radius);
    float x_mu_s = mu_s * 0.5 + 0.5;
    return GetTextureCoordFromUnitRange(vec2(x_mu_s, x_r), textureSize(irradiance_texture, 0));
}

vec3 GetIrradiance(float r, float mu_s) {
    vec2 uv = GetIrradianceTextureUvFromRMuS(r, mu_s);
    return vec3(texture(irradiance_texture, uv));
}

vec3 ComputeScatteringDensity(
        float r, float mu, float mu_s, float nu, int scattering_order) {
    // Compute unit direction vectors for the zenith, the view direction omega and
    // and the sun direction omega_s, such that the cosine of the view-zenith
    // angle is mu, the cosine of the sun-zenith angle is mu_s, and the cosine of
    // the view-sun angle is nu. The goal is to simplify computations below.
    vec3 zenith_direction = vec3(0.0, 0.0, 1.0);
    vec3 omega = vec3(sqrt(1.0 - mu * mu), 0.0, mu);
    float sun_dir_x = omega.x == 0.0 ? 0.0 : (nu - mu * mu_s) / omega.x;
    float sun_dir_y = sqrt(max(1.0 - sun_dir_x * sun_dir_x - mu_s * mu_s, 0.0));
    vec3 omega_s = vec3(sun_dir_x, sun_dir_y, mu_s);

    const int SAMPLE_COUNT = 16;
    const float dphi = PI / float(SAMPLE_COUNT);
    const float dtheta = PI / float(SAMPLE_COUNT);
    vec3 rayleigh_mie = vec3(0.0);

    // Nested loops for the integral over all the incident directions omega_i.
    for (int l = 0; l < SAMPLE_COUNT; ++l) {
        float theta = (float(l) + 0.5) * dtheta;
        float cos_theta = cos(theta);
        float sin_theta = sin(theta);
        bool ray_r_theta_intersects_ground = RayIntersectsGround(r, cos_theta);

        // The distance and transmittance to the ground only depend on theta, so we
        // can compute them in the outer loop for efficiency.
        float distance_to_ground = 0.0;
        vec3 transmittance_to_ground = vec3(0.0);
        vec3 real_ground_albedo = vec3(0.0);
        if (ray_r_theta_intersects_ground) {
            distance_to_ground = DistanceToBottomAtmosphereBoundary(r, cos_theta);
            transmittance_to_ground =
                GetTransmittance(transmittance_texture, r, cos_theta,
                    distance_to_ground, true /* ray_intersects_ground */);
            real_ground_albedo = ground_albedo;
        }

        for (int m = 0; m < 2 * SAMPLE_COUNT; ++m) {
            float phi = (float(m) + 0.5) * dphi;
            vec3 omega_i =
                vec3(cos(phi) * sin_theta, sin(phi) * sin_theta, cos_theta);
            float domega_i = dtheta * dphi * sin(theta);

            // The radiance L_i arriving from direction omega_i after n-1 bounces is
            // the sum of a term given by the precomputed scattering texture for the
            // (n-1)-th order:
            float nu1 = dot(omega_s, omega_i);
            vec3 incident_radiance = GetScattering(
                single_rayleigh_scattering_texture, single_mie_scattering_texture,
                multiple_scattering_texture, r, omega_i.z, mu_s, nu1,
                ray_r_theta_intersects_ground, scattering_order - 1);

            // and of the contribution from the light paths with n-1 bounces and whose
            // last bounce is on the ground. This contribution is the product of the
            // transmittance to the ground, the ground albedo, the ground BRDF, and
            // the irradiance received on the ground after n-2 bounces.
            vec3 ground_normal =
                normalize(zenith_direction * r + omega_i * distance_to_ground);
            vec3 ground_irradiance = GetIrradiance(bottom_radius, dot(ground_normal, omega_s));
            incident_radiance += transmittance_to_ground *
                real_ground_albedo * (1.0 / PI) * ground_irradiance;

            // The radiance finally scattered from direction omega_i towards direction
            // -omega is the product of the incident radiance, the scattering
            // coefficient, and the phase function for directions omega and omega_i
            // (all this summed over all particle types, i.e. Rayleigh and Mie).
            float nu2 = dot(omega, omega_i);
            
            vec3 rayleigh_scattering_i;
            vec3 mie_scattering_i;
            GetScatteringCoefficient(r - bottom_radius, rayleigh_scattering_i, mie_scattering_i);

            rayleigh_mie += incident_radiance * (
                rayleigh_scattering_i * RayleighPhaseFunction(nu2) +
                mie_scattering_i * MiePhaseFunction(nu2, mie_phase_g)
                ) * domega_i;
        }
    }
    return rayleigh_mie;
}

vec3 ComputeScatteringDensityTexture(vec3 frag_coord) {
  float r;
  float mu;
  float mu_s;
  float nu;
  bool ray_r_mu_intersects_ground;
  GetRMuMuSNuFromScatteringTextureFragCoord(frag_coord,
      r, mu, mu_s, nu, ray_r_mu_intersects_ground);
  return ComputeScatteringDensity(r, mu, mu_s, nu, scattering_order);
}

void main() {
	vec3 frag_coord = vec3(gl_GlobalInvocationID) + 0.5;
	vec3 scattering_density = ComputeScatteringDensityTexture(frag_coord);
    imageStore(scattering_density_image, ivec3(gl_GlobalInvocationID.xyz), vec4(scattering_density, 1.0));
}
