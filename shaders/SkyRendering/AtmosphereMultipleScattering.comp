/*
This code contains portions of source code from 
https://github.com/ebruneton/precomputed_atmospheric_scattering/blob/master/atmosphere/functions.glsl
Copyright (c) 2017 Eric Bruneton
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. Neither the name of the copyright holders nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.
*/

#version 460
#include "Atmosphere.glsl"

layout(binding = 0) uniform sampler3D scattering_density_texture;

layout(binding = 0, SCATTERING_FORMAT) uniform image3D delta_multiple_scattering_image;
layout(binding = 1, SCATTERING_FORMAT) uniform image3D scattering_image;

vec3 ComputeMultipleScattering(
        float r, float mu, float mu_s, float nu,
        bool ray_r_mu_intersects_ground) {

    // Number of intervals for the numerical integration.
    const int SAMPLE_COUNT = 50;
    // The integration step, i.e. the length of each integration interval.
    float dx =
        DistanceToNearestAtmosphereBoundary(
            r, mu, ray_r_mu_intersects_ground) /
                float(SAMPLE_COUNT);
    // Integration loop.
    vec3 rayleigh_mie_sum = vec3(0.0);
    vec3 transmittance = vec3(1.0);
    for (int i = 0; i < SAMPLE_COUNT; ++i) {
        float d_i = (float(i) + 0.5) * dx;

        // The r, mu and mu_s parameters at the current integration point (see the
        // single scattering section for a detailed explanation).
        float r_i = ClampRadius(sqrt(d_i * d_i + 2.0 * r * mu * d_i + r * r));
        float mu_i = ClampCosine((r * mu + d_i) / r_i);
        float mu_s_i = ClampCosine((r * mu_s + d_i * nu) / r_i);
        
        vec3 extinction_i = GetExtinctionCoefficient(r_i - bottom_radius);
        vec3 transmittance_i = exp(-extinction_i * dx);

        // The Rayleigh and Mie multiple scattering at the current sample point.
        vec3 rayleigh_mie_i =
            GetScattering(
                scattering_density_texture, r_i, mu_i, mu_s_i, nu,
                ray_r_mu_intersects_ground);
        // See slide 28 at https://www.frostbite.com/2015/08/physically-based-unified-volumetric-rendering-in-frostbite/
        rayleigh_mie_sum += transmittance * (rayleigh_mie_i - rayleigh_mie_i * transmittance_i) / extinction_i;
        transmittance *= transmittance_i;
    }
    return rayleigh_mie_sum;
}

vec3 ComputeMultipleScatteringTexture(vec3 frag_coord, out float nu) {
    float r;
    float mu;
    float mu_s;
    bool ray_r_mu_intersects_ground;
    GetRMuMuSNuFromScatteringTextureFragCoord(frag_coord,
        r, mu, mu_s, nu, ray_r_mu_intersects_ground);
    return ComputeMultipleScattering(
        r, mu, mu_s, nu,
        ray_r_mu_intersects_ground);
}

void main() {
	vec3 frag_coord = vec3(gl_GlobalInvocationID) + 0.5;

    float nu;
    vec3 delta_multiple_scattering = ComputeMultipleScatteringTexture(frag_coord, nu);
    imageStore(delta_multiple_scattering_image, ivec3(gl_GlobalInvocationID), vec4(delta_multiple_scattering, 0));
    vec4 scattering = vec4(delta_multiple_scattering.rgb / RayleighPhaseFunction(nu), 0.0);
    imageStore(scattering_image, ivec3(gl_GlobalInvocationID), 
        imageLoad(scattering_image, ivec3(gl_GlobalInvocationID)) + scattering);
}
