#include "VolumetricCloudRenderCommon.glsl"

layout(binding = 0) uniform sampler2D checkerboard_depth;
layout(binding = 1) uniform sampler2D index_linear_depth_texture;
layout(binding = 2) uniform sampler2D transmittance_texture;
layout(binding = 3) uniform sampler3D aerial_perspective_luminance_texture;
layout(binding = 4) uniform sampler3D aerial_perspective_transmittance_texture;
layout(binding = 5) uniform sampler2D blue_noise;
layout(binding = 6) uniform sampler3D shadow_froxel;

layout(binding = 0, rgba16f) uniform image2D render_image;
layout(binding = 1, r32f) uniform image2D cloud_distance_image;

struct Intersect {
    float t1;
    float t2;
};

Intersect[2] RayShellIntersect(float r, float mu) {
    Intersect[2] res;
    res[0].t1 = res[0].t2 = res[1].t1 = res[1].t2 = 0.0;
    float bottom_radius = uEarthRadius + uBottomAltitude;
    float top_radius = uEarthRadius + uTopAltitude;
    float discriminant_bottom = r * r * (mu * mu - 1.0) + bottom_radius * bottom_radius;
    float discriminant_top = r * r * (mu * mu - 1.0) + top_radius * top_radius;
    float sqrt_discriminant_bottom = sqrt(max(discriminant_bottom, 0));
    float sqrt_discriminant_top = sqrt(max(discriminant_top, 0));
    if (uCameraPos.z < uBottomAltitude) {
        res[0].t1 = -r * mu + sqrt_discriminant_bottom;
        res[0].t2 = -r * mu + sqrt_discriminant_top;
    } else if (uCameraPos.z < uTopAltitude) {
        if (discriminant_bottom >= 0.0 && mu < 0.0) {
            res[0].t2 = -r * mu - sqrt_discriminant_bottom;
            res[1].t1 = -r * mu + sqrt_discriminant_bottom;
            res[1].t2 = -r * mu + sqrt_discriminant_top;
        } else {
            res[0].t2 = -r * mu + sqrt_discriminant_top;
        }
    } else /*if (uCameraPos.z >= uTopAltitude)*/{
        if (discriminant_bottom >= 0.0 && mu < 0.0) {
            res[0].t1 = -r * mu - sqrt_discriminant_top;
            res[0].t2 = -r * mu - sqrt_discriminant_bottom;
            res[1].t1 = -r * mu + sqrt_discriminant_bottom;
            res[1].t2 = -r * mu + sqrt_discriminant_top;
        } else if (discriminant_top >= 0.0 && mu < 0.0) {
            res[0].t1 = -r * mu - sqrt_discriminant_top;
            res[0].t2 = -r * mu + sqrt_discriminant_top;
        }
    }
    return res;
}

struct RayMarchContext {
    float rand;
    float t_base;
    float t;
    float t_end;
    vec3 pos;
    float height01;
    float step_size;
    float transmittance;
    float weight_sum;
    float weighted_t_sum;
    vec2 sun_env;
    float cos_sun_view;
};

void UpdateContext(inout RayMarchContext ctx, vec3 view_dir) {
#if 0
    const float kMaxStepScale = 4.0;
    const float kMinStepScale = 0.7;
    const float kBase = kMinStepScale * (kMaxStepScale - 1.0) / (kMaxStepScale - kMinStepScale);
    float lerp_a = max(ctx.cos_sun_view, kMinStepScale / kMaxStepScale);
    float step_scale = mix(kBase, 1.0, lerp_a) / mix(ctx.transmittance, 1.0, lerp_a);
    ctx.step_size = min(uBaseStepSize * step_scale, ctx.t_end - ctx.t_base);
#else
    ctx.step_size = min(uBaseStepSize, ctx.t_end - ctx.t_base);    
#endif
    ctx.t = ctx.t_base + ctx.step_size * ctx.rand;
    ctx.pos = uCameraPos + view_dir * ctx.t;
    ctx.height01 = CalHeight01(ctx.pos);
}

void RayMarchStep(inout RayMarchContext ctx) {
    CloudSampleResult res = DefaultCloudSampleResult();
    SampleCloudWithCheck(CloudSampleParams(ctx.pos, ctx.height01, uCameraPos, CLOUD_SAMPLE_MAIN_RAY), res);
    float sigma_t = res.sigma_t;
    if (sigma_t < 1e-5)
        return;
    float tr = exp(-ctx.step_size * sigma_t);
    vec2 sun_env = vec2(0);
    float optical_depth = SampleOpticalDepth(ctx.pos);

    for (int i = 0; i < 8; ++i) {
        sun_env.r += pow(res.contribution, i) * exp(-optical_depth * pow(res.attenuation, i))
            * HenyeyGreenstein(ctx.cos_sun_view, pow(res.phase_g, i + 1));
    }
#if 0
    sun_env.r = mix(HenyeyGreenstein(ctx.cos_sun_view, -0.15) * 2.16 * exp(-optical_depth), sun_env.r, exp(-0.3 * sigma_t));
#endif
    sun_env.g = mix(uEnvBottomVisibility, 1.0, ctx.height01);
    sun_env.g = sun_env.g - sun_env.g * exp(-uEnvMultiscatteringSigmaScale * sigma_t);

    sun_env = sun_env - sun_env * tr;
    ctx.sun_env += ctx.transmittance * sun_env;
    ctx.transmittance *= tr;
    float weight =  ctx.transmittance;
    ctx.weight_sum += weight;
    ctx.weighted_t_sum += ctx.t * weight;
}

void Raymarch(inout RayMarchContext ctx, vec3 view_dir) {
    while (true) {
        UpdateContext(ctx, view_dir);
        if (ctx.step_size <= 0 || ctx.transmittance < kMinTransmittance)
            break;
        RayMarchStep(ctx);
        ctx.t_base += ctx.step_size;
    }
}

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    uint index = uint(texelFetch(index_linear_depth_texture, pos, 0).r);
    ivec2 pos_in_checkerboard = pos * 2 + IndexToOffset(index);

    ivec2 image_size = textureSize(checkerboard_depth, 0);
    vec2 uv = (vec2(pos_in_checkerboard) + 0.5) / image_size;
    float depth = texelFetch(checkerboard_depth, pos_in_checkerboard, 0).x;
    vec3 frag_pos = UvDepthToPos(uInvMVP, uv, depth);
    vec3 view_dir = UvToDir(uInvMVP, uv);
    
    float r = uCameraPos.z + uEarthRadius;
    float mu = view_dir.z;
    Intersect[2] intersect = RayShellIntersect(r, mu);
    float frag_dist = depth != 0.0 ? distance(frag_pos, uCameraPos) : uMaxVisibleDistance;
    for (int i = 0; i < 2; ++i) {
        intersect[i].t1 = max(intersect[i].t1, uLightFroxelMaxDist);
        intersect[i].t2 = clamp(min(frag_dist, uMaxVisibleDistance), intersect[i].t1, intersect[i].t2);
    }

    RayMarchContext ctx;
    ctx.cos_sun_view = dot(uSunDirection, view_dir);
    float noise = texelFetch(blue_noise, pos & 0x3f, 0).x;
    ctx.rand = fract(noise + uFrameID * 0.61803398875);
    ctx.transmittance = 1.0;
    ctx.weight_sum = 0.0;
    ctx.weighted_t_sum = 0.0;
    ctx.sun_env = vec2(0.0);

    float dist = intersect[0].t2 - intersect[0].t1;
    dist = min(dist, uMaxRaymarchDistance);
    ctx.step_size = uBaseStepSize;
    ctx.t_base = intersect[0].t1;
    ctx.t_end = intersect[0].t1 + dist;
    Raymarch(ctx, view_dir);
    float dist1 = intersect[1].t2 - intersect[1].t1;
    if (dist1 > 0) {
        dist1 = min(dist1, uMaxRaymarchDistance);
        ctx.step_size = uBaseStepSize;
        ctx.t_base = intersect[1].t1;
        ctx.t_end = intersect[1].t1 + dist1;
        Raymarch(ctx, view_dir);
    }
    float average_t = ctx.weighted_t_sum == 0 ? frag_dist : ctx.weighted_t_sum / ctx.weight_sum;
    imageStore(cloud_distance_image, pos, vec4(average_t));

    vec3 average_pos = uCameraPos + view_dir * average_t;
    vec3 luminance = ctx.sun_env.r * uSunIlluminanceScale * GetSunVisibility(transmittance_texture, average_pos) * solar_illuminance
                   + ctx.sun_env.g * pow(SunCosTheta(average_pos), uEnvSunHeightCurveExp) * uEnvColorScale;
    
    vec3 atmosphere_transmittance;
    vec3 atmosphere_luminance = GetAerialPerspective(aerial_perspective_luminance_texture,
        aerial_perspective_transmittance_texture, uv, average_t, r, mu, atmosphere_transmittance);
    atmosphere_luminance *= SampleRayScatterVisibility(shadow_froxel, uv, average_t, uInvShadowFroxelMaxDistance);

    luminance = luminance * atmosphere_transmittance + atmosphere_luminance * (1 - ctx.transmittance);

#if 1
    luminance /= max(1e-5, (1 - ctx.transmittance));
    float fade = smoothstep(uMaxVisibleDistance * 0.75, uMaxVisibleDistance, intersect[0].t1);
    ctx.transmittance = mix(ctx.transmittance, 1.0, fade);
    luminance *= 1 - ctx.transmittance;
#endif
    
    imageStore(render_image, pos, vec4(luminance, ctx.transmittance));
}
