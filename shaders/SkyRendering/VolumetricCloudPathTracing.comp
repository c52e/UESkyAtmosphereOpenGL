#include "VolumetricCloudCommon.glsl"
#include "VolumetricCloudShadowInterface.glsl"
#include "../Base/Noise.glsl"

layout(local_size_x = LOCAL_SIZE_X, local_size_y = LOCAL_SIZE_Y) in;

layout(binding = 0) uniform sampler2D transmittance_texture;
layout(binding = 1) uniform sampler3D aerial_perspective_luminance_texture;
layout(binding = 2) uniform sampler3D aerial_perspective_transmittance_texture;
layout(binding = 3) uniform sampler3D shadow_froxel;
layout(binding = 4) uniform samplerCube environment_luminance_texture;

layout(binding = 0, rgba32f) uniform image2D accumulating_image;
layout(binding = 1, r8ui) uniform uimage2D rendered_mask_image;
layout(binding = 2, rgba16f) uniform image2D display_image;

layout(location = 0) uniform uint kFrameId;
layout(location = 1) uniform ivec4 kRenderRegion;

vec2 gUv = vec2(0.0);

const vec2 kCloudCenter = vec2(0.0);

// https://github.com/sebh/UnrealEngineSkyAtmosphere
// https://graphics.pixar.com/library/ProductionVolumeRendering/

struct Ray {
    vec3 o;
    vec3 d;
};

Ray CreateRay(vec3 o, vec3 d) {
    Ray r;
    r.o = o;
    r.d = d;
    return r;
}

struct Context {
    uint seed;
    Ray ray;
    float sigma_t_max;
};

float Random01(inout Context ctx) {
    float res = float(ctx.seed) / (4294967296.0);
    ctx.seed = PRNG(ctx.seed);
    return res;
}

vec3 UniformSphereSample(inout Context ctx) {
    float phi = 2.0 * PI * Random01(ctx);
    float cos_theta = 1.0 - 2.0 * Random01(ctx);
    float sin_theta = sqrt(clamp(1.0 - cos_theta * cos_theta, 0, 1));
    return vec3(cos(phi) * sin_theta, sin(phi) * sin_theta  , cos_theta);
}

#ifdef REGION_SHAPE_BOX
const vec3 kCloudAABBMin = vec3(kCloudCenter - vec2(kCloudRegionRadius), uBottomAltitude);
const vec3 kCloudAABBMax = vec3(kCloudCenter + vec2(kCloudRegionRadius), uTopAltitude);

vec2 CloudRegionIntersect(Ray ray) {
    vec2 t = vec2(0, 1e7);
    for (int i = 0; i < 3; ++i) {
//        if (abs(ray.d[i]) < 1e-7) {
//            if (ray.o[i] < kCloudAABBMin[i] || ray.o[i] > kCloudAABBMax[i])
//                return vec2(0);
//            else
//                continue;
//        }
        float t1 = (kCloudAABBMin[i] - ray.o[i]) / ray.d[i];
        float t2 = (kCloudAABBMax[i] - ray.o[i]) / ray.d[i];
        float tmin = min(t1, t2);
        float tmax = max(t1, t2);
        t.x = max(t.x, tmin);
        t.y = min(t.y, tmax);
    }

    return t;
}

//bool IsInsideCloudRegion(vec3 p) {
//    const float kMargin = 0.01; // More robust
//    return all(clamp(p, kCloudAABBMin - kMargin, kCloudAABBMax + kMargin) == p);
//}

float GetHeight(vec3 P) {
    return clamp((P.z - uBottomAltitude) / (uTopAltitude - uBottomAltitude), 0, 1);
}
#endif

#ifdef REGION_SHAPE_SPHERE
vec2 CloudRegionIntersect(Ray ray) {
    float r = length(ray.o + vec3(0, 0, uEarthRadius));
    float mu = dot(ray.d, normalize(ray.o + vec3(0, 0, uEarthRadius)));
    vec2 t = vec2(0.0);

    float bottom_radius = uEarthRadius + uBottomAltitude;
    float top_radius = uEarthRadius + uTopAltitude;
    float discriminant_bottom = r * r * (mu * mu - 1.0) + bottom_radius * bottom_radius;
    float discriminant_top = r * r * (mu * mu - 1.0) + top_radius * top_radius;
    float sqrt_discriminant_bottom = sqrt(discriminant_bottom);
    float sqrt_discriminant_top = sqrt(discriminant_top);
    if (r < bottom_radius) {
        t.x = -r * mu + sqrt_discriminant_bottom;
        t.y = -r * mu + sqrt_discriminant_top;
    } else if (r < top_radius) {
        t.y = -r * mu + (discriminant_bottom >= 0.0 && mu < 0.0 ? -sqrt_discriminant_bottom : sqrt_discriminant_top);
    } else /*if (r >= top_radius)*/{
        if (discriminant_bottom >= 0.0 && mu < 0.0) {
            t.x = -r * mu - sqrt_discriminant_top;
            t.y = -r * mu - sqrt_discriminant_bottom;
        } else if (discriminant_top >= 0.0 && mu < 0.0) {
            t.x = -r * mu - sqrt_discriminant_top;
            t.y = -r * mu + sqrt_discriminant_top;
        }
    }
    if (t.y > t.x) { // Intersect with kCloudRegionRadius sphere
        float r_cull = length(ray.o - vec3(kCloudCenter, 0));
        float mu_cull = dot(ray.d, normalize(ray.o - vec3(kCloudCenter, 0)));
        vec2 t_cull = vec2(0);

        float discriminant_cull = r_cull * r_cull * (mu_cull * mu_cull - 1.0) + kCloudRegionRadius * kCloudRegionRadius;
        float sqrt_discriminant_cull = sqrt(discriminant_cull);
        if (r_cull < kCloudRegionRadius) {
            t_cull.y = -r_cull * mu_cull + sqrt_discriminant_cull;
        } else {
            if (discriminant_cull >= 0.0 && mu_cull < 0.0) {
                t_cull.x = -r_cull * mu_cull - sqrt_discriminant_cull;
                t_cull.y = -r_cull * mu_cull + sqrt_discriminant_cull;
            }
        }
        t.x = max(t.x, t_cull.x);
        t.y = min(t.y, t_cull.y);
    }

    return t;
}

//bool IsInsideCloudRegion(vec3 p) {
//    float d0 = length(p + vec3(0, 0, uEarthRadius)) - uEarthRadius;
//    float d1 = length(vec3(kCloudCenter, 0) - p);
//    return d0 >= uBottomAltitude && d0 <= uTopAltitude && d1 < kCloudRegionRadius;
//}

float GetHeight(vec3 P) {
    return CalHeight01(P);
}
#endif

float InfiniteTransmittanceIS(float sigma_t, float zeta) {
    return -log(1.0 - zeta) / sigma_t;
}

float SampleSigmaTWithCheck(vec3 P) {
    CloudSampleResult res = DefaultCloudSampleResult();
    SampleCloudWithCheck(CloudSampleParams(P, GetHeight(P), uCameraPos, CLOUD_SAMPLE_PATH_TRACING), res);
    return res.sigma_t;
}

float GetPhase(float cos_theta) {
    return mix(HenyeyGreenstein(cos_theta, kBackPhaseG),
                HenyeyGreenstein(cos_theta, kForwardPhaseG), kForwardScatteringRatio);
}

void GenerateHGSample(inout Context ctx, out vec3 direction, out float value_over_pdf) {
#if IMPORTANCE_SAMPLING
    float g = Random01(ctx) < kForwardScatteringRatio ? kForwardPhaseG : kBackPhaseG;
    float cos_theta = HenyeyGreensteinInvertcdf(Random01(ctx), g);
    float sin_theta = sqrt(clamp(1.0 - cos_theta * cos_theta, 0, 1));
    vec3 t0, t1;
    CreateOrthonormalBasis(ctx.ray.d, t0, t1);
    float phi = 2.0 * PI * Random01(ctx);
    direction = vec3(sin_theta * sin(phi) * t0 + sin_theta * cos(phi) * t1 + cos_theta * ctx.ray.d);

//    value = GetPhase(dot(ctx.ray.d, direction));
//    pdf = value;
    value_over_pdf = 1.0;
#else
    direction = UniformSphereSample(ctx);
    float value = GetPhase(dot(ctx.ray.d, direction));
    float pdf = 1.0 / (4.0 * PI);
    value_over_pdf = value / pdf;
#endif
}

void GenerateLambertSample(inout Context ctx, vec3 N, vec3 albedo, out vec3 direction, out vec3 value_over_pdf) {
    float sin_theta = sqrt(Random01(ctx));
    float cos_theta = sqrt(clamp(1.0 - sin_theta * sin_theta, 0, 1));
    vec3 t0, t1;
    CreateOrthonormalBasis(N, t0, t1);
    float phi = 2.0 * PI * Random01(ctx);
    direction = vec3(sin_theta * sin(phi) * t0 + sin_theta * cos(phi) * t1 + cos_theta * N);
//    value = albedo * INV_PI * cos_theta;
//    pdf = INV_PI * cos_theta;
    value_over_pdf = albedo;
}

vec3 GetSunIlluminance(vec3 pos) {
    return GetSunVisibility(transmittance_texture, pos) * solar_illuminance;
}

const bool kHalfScreenWeightedTracking = false;

float TransmittanceEstimation(Context ctx, Ray ray) {
    float transmittance = 1.0;
    vec2 inter_t = CloudRegionIntersect(ray);
    if (inter_t.x >= inter_t.y)
        return transmittance;
    
    float t = inter_t.x;

if (!kHalfScreenWeightedTracking || gUv.x > 0.5) {
#define TRACKING_BODY \
    t += InfiniteTransmittanceIS(ctx.sigma_t_max, Random01(ctx)); \
    if (t > inter_t.y) \
        return clamp(transmittance, 0, 1); \
    float sigma_t = SampleSigmaTWithCheck(ray.o + ray.d * t); \
    float ratio = max(0, sigma_t / ctx.sigma_t_max)
        
    for (int i = 0; i < kMaxRatioTrackingSteps; ++i) {
        TRACKING_BODY;
        transmittance *= 1.0 - ratio; 
    }

    while (true) {
        TRACKING_BODY;
        if (Random01(ctx) < ratio)
            break;
    }
#undef TRACKING_BODY
} else {
    float sigma_t_max = ctx.sigma_t_max * 1;
    for (int i = 0; i < kMaxRatioTrackingSteps; ++i) {
        t += InfiniteTransmittanceIS(sigma_t_max, Random01(ctx));
        if (t > inter_t.y)
            return transmittance;
        float sigma_t = SampleSigmaTWithCheck(ray.o + ray.d * t);
        float ratio = max(0, sigma_t / sigma_t_max);
        transmittance *= 1.0 - ratio; 
    }
    // weighted delta tracking
    // https://jannovak.info/publications/SDTracking/SDTracking.pdf
    while (true) {
        t += InfiniteTransmittanceIS(sigma_t_max, Random01(ctx));
        if (t > inter_t.y)
            return transmittance;
        float sigma_t = SampleSigmaTWithCheck(ray.o + ray.d * t);
        float sigma_n = sigma_t_max - sigma_t;
        float p_s = sigma_t / (sigma_t + abs(sigma_n));
        float p_n = 1.0 - p_s;
        if (Random01(ctx) < p_s)
            break;
        transmittance *= sign(sigma_n) * (sigma_t + abs(sigma_n)) / sigma_t_max;
    }
}
    return 0.0;
}

vec3 SampleLuminanceFromLight(inout Context ctx, vec3 pos, vec3 bsdf_with_cosine) {
    const float kSunSolidAngle = 1.0; // This should be an infinitesimal, but has no effect on the final result
    vec3 light_luminance = GetSunIlluminance(pos) / kSunSolidAngle;
    float pdf = 1.0 / kSunSolidAngle;
    return TransmittanceEstimation(ctx, CreateRay(pos, uSunDirection)) * light_luminance * bsdf_with_cosine / pdf;
}

bool ScatterTest(inout Context ctx, out float t, inout vec3 throughput) {
    while (true) {
        vec2 inter_t = CloudRegionIntersect(ctx.ray);
        if (inter_t.x >= inter_t.y)
            return false;
        float t_max = inter_t.y;
        t = inter_t.x;
        while (true) {
            t += InfiniteTransmittanceIS(ctx.sigma_t_max, Random01(ctx));
            if (t > t_max) {
                // Don't return false. This will handle multiple segments. 
                ctx.ray.o += ctx.ray.d * t;
                break;
            }

            vec3 P = ctx.ray.o + ctx.ray.d * t;
            float sigma_t = SampleSigmaTWithCheck(P);

if (!kHalfScreenWeightedTracking || gUv.x > 0.5) {
		    float xi = Random01(ctx);
            if (xi < sigma_t / ctx.sigma_t_max)
                return true;
} else {
            // weighted delta tracking
            // https://jannovak.info/publications/SDTracking/SDTracking.pdf
            float sigma_t_max = ctx.sigma_t_max * 0.3;
            float sigma_n = sigma_t_max - sigma_t;
            float p_s = sigma_t / (sigma_t + abs(sigma_n));
            float p_n = 1.0 - p_s;
            if (Random01(ctx) < p_s) {
                throughput *= (sigma_t + abs(sigma_n)) / sigma_t_max;
                return true;
            }   
            throughput *= sign(sigma_n) * (sigma_t + abs(sigma_n)) / sigma_t_max;       
}
        }
    }
    return false;
}

// https://computergraphics.stackexchange.com/questions/2316/is-russian-roulette-really-the-answer
bool RussianRoulette(inout Context ctx, inout vec3 throughput) {
    float p = clamp(max(throughput.r, max(throughput.g, throughput.b)), 0, 1);
    if (Random01(ctx) > p)
        return false;
    throughput /= p;
    return true;
}

vec4 Trace(inout Context ctx, vec3 view_dir, out bool has_scattered, out float scattered_t) {
    // Should tracing atmosphere for better result
    vec3 L = vec3(0.0);
    vec3 throughput = vec3(1.0);
    has_scattered = false;
    ctx.ray = CreateRay(uCameraPos, view_dir);
    vec2 camera_inter_t = CloudRegionIntersect(ctx.ray);
    //return vec4(vec3(clamp(1 - exp(-(camera_inter_t.y - camera_inter_t.x) / 50), 0, 1)), 0.0);
    if (camera_inter_t.x >= camera_inter_t.y)
        return vec4(L, throughput);

    ctx.ray.o += camera_inter_t.x * ctx.ray.d;
    int istep = 0;
    while (istep < kMaxBounces && RussianRoulette(ctx, throughput)) {
//        if (!IsInsideCloudRegion(ctx.ray.o))
//            break;
        float t;
        if (!ScatterTest(ctx, t, throughput)) {
#ifdef ENVIRONMENT_LIGHT_OFF
            break;
#endif
            if (!has_scattered) 
                break;

#ifdef ENVIRONMENT_LIGHT_CONST_ENVIRONMENT_MAP
            L += throughput * texture(environment_luminance_texture, kModelMatrix3 * ctx.ray.d).rgb;
            break;
#endif

	        vec3 up_dir = vec3(ctx.ray.o.xy, ctx.ray.o.z + uEarthRadius);
	        float r = length(up_dir);
	        up_dir /= r;
	        float mu = dot(ctx.ray.d, up_dir);
            if (!RayIntersectsGround(r, mu)) {
                L += throughput * texture(environment_luminance_texture, kModelMatrix3 * ctx.ray.d).rgb;
                break;
            }
            ctx.ray.o += ctx.ray.d * DistanceToBottomAtmosphereBoundary(r, mu);
            vec3 ground_normal = normalize(vec3(ctx.ray.o.xy, ctx.ray.o.z + uEarthRadius));
            vec3 light_bsdf = INV_PI * ground_albedo;
            float NdotL = dot(ground_normal, uSunDirection);
            L += throughput * SampleLuminanceFromLight(ctx, ctx.ray.o, light_bsdf * NdotL);

#ifdef ENVIRONMENT_LIGHT_GROUND_SINGLE_BOUNCE
            break;
#endif

            vec3 bsdf_with_cosine_over_pdf;
            GenerateLambertSample(ctx, ground_normal, ground_albedo, ctx.ray.d, bsdf_with_cosine_over_pdf);
            throughput *= bsdf_with_cosine_over_pdf;
        } else {
            if (!has_scattered)
                scattered_t = distance(uCameraPos, ctx.ray.o);
            has_scattered = true;

            ctx.ray.o += ctx.ray.d * t;
            float light_bsdf = GetPhase(dot(ctx.ray.d, uSunDirection));
            L += throughput * SampleLuminanceFromLight(ctx, ctx.ray.o, vec3(light_bsdf));
            
            float bsdf_over_pdf;
            GenerateHGSample(ctx, ctx.ray.d, bsdf_over_pdf);
            throughput *= bsdf_over_pdf;
        }
        
        ++istep;
    }

    return vec4(L, has_scattered ? 0.0 : 1.0);
}

#ifndef DISPLAY_PASS


void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy) + kRenderRegion.xy;
    if (pos.x >= kRenderRegion.z || pos.y >= kRenderRegion.w)
        return;
    Context ctx;
    ctx.seed = PRNG(PRNG(PRNG(uint(pos.x)) + uint(pos.y)) + kFrameId);
    ctx.sigma_t_max = kSigmaTMax;

    vec2 uv = (vec2(pos) + 0.5) / vec2(imageSize(display_image));
    gUv = uv;
    vec3 view_dir = UvToDir(uInvMVP, uv);

    bool has_scattered;
    float scattered_t;
    vec4 this_res = Trace(ctx, view_dir, has_scattered, scattered_t);
    if (has_scattered) {
        // Apply atmosphere scattering
        float r = uCameraPos.z + uEarthRadius;
        float mu = view_dir.z;
        vec3 atmosphere_transmittance;
        vec3 atmosphere_luminance = GetAerialPerspective(aerial_perspective_luminance_texture,
            aerial_perspective_transmittance_texture, uv, scattered_t, r, mu, atmosphere_transmittance);
        atmosphere_luminance *= SampleRayScatterVisibility(shadow_froxel, uv, scattered_t, uInvShadowFroxelMaxDistance);
        this_res.rgb = this_res.rgb * atmosphere_transmittance + atmosphere_luminance;
    }

    vec4 accumulated = imageLoad(accumulating_image, pos) + this_res;
    imageStore(accumulating_image, pos, vec4(accumulated));
    imageStore(rendered_mask_image, pos, uvec4(1));
}

#else

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    vec4 accumulated = imageLoad(accumulating_image, pos);
    vec4 color = imageLoad(display_image, pos);
    bool is_rendered = imageLoad(rendered_mask_image, pos).r != 0;
    vec4 avg_res = accumulated / float(is_rendered ? kFrameId : kFrameId - 1);
    color.rgb = color.rgb * avg_res.a + avg_res.rgb;
    imageStore(display_image, pos, color);
}

#endif
